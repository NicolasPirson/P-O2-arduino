def difference_in_position(block, other_block):
    """
        Finds difference in coördinates of the smallest blocks in block and other block
    """
    blockmin = min(block)
    other_blockmin = min(other_block)
    if blockmin > other_blockmin:
        return ((blockmin[0] - other_blockmin[0]), (blockmin[1] - other_blockmin[1]))
    else:
        return ((other_blockmin[0] - blockmin[0]), (other_blockmin[1] - blockmin[1]))

def make_equal(block, other_block):
    """
        Makes it so the coördinates of the smallest cells in the block and other_block become the same.
    """
    if min(block) > min(other_block):
        diff = difference_in_position(block,other_block)
        new_block = set()
        for pos in block:
            new_pos = Position.translate_over(pos, -diff[0], -diff[1])
            new_block.add(new_pos)
        return (new_block, other_block)
    if min(other_block) > min(block):
        diff = difference_in_position(block, other_block)
        new_other_block = set()
        for pos in other_block:
            new_pos1 = Position.translate_over(pos, -diff[0], -diff[1])
            new_other_block.add(new_pos1)
        return (block,new_other_block)

def are_equivalent(block, other_block):
    """
       Check whether the given blocks are equivalent, i.e. cover equivalent
       chains of dots.
       - A block is equivalent with some other block , if there exists a position
         for the anchor of the one block such that the set of dots covered by that
         block relative towards that anchor position, is identical to the set of
         dots covered by the other block.
        ASSUMPTIONS
        - Both given blocks are proper blocks.
    """
    if len(block) != len(other_block):
        return False
    # block = list(block)
    # other_block = list(block)
    to_check = make_equal(block,other_block)
    block = to_check[0]
    other_block = to_check[1]
    if len(block.intersection(other_block)) == len(block):
        return True
    else:
        return False



    # for pos1 in block:
    #     x1 = pos1[0]
    #     y1 = pos1[1]
    #     xlist1.append(x1)
    #     ylist1.append(y1)
    # for pos2 in other_block:
    #     x2 = pos2[0]
    #     y2 = pos2[1]
    #     xlist1.append(x2)
    #     ylist1.append(y2)



# single dot blocks
the_block = make_block({(0, 0)})
other_block = make_block({(1, 3)})
assert are_equivalent(the_block, other_block)
# one-dimensional blocks
the_block = make_block({(-2, 2), (-2, 3), (-2, 4), (-2, 5)})
other_block = make_block({(0, 0), (0, 1), (0, 2), (0, 3)})
assert are_equivalent(the_block, other_block)
#two-dimensional blocks
the_block = make_block({(0, 0), (1, 0), (0, 1), (1, 1)})
other_block = make_block({(-2, 3), (-1, 3), (-2, 4), (-1, 4)})
assert are_equivalent(the_block, other_block)

# blocks with different number of dots.
the_block = make_block({(0, 0), (1, 0), (0, 1), (1, 1)})
other_block = make_block({(-2, 3), (-1, 3), (-2, 4), (-1, 4), (-1, 5)})
assert not are_equivalent(the_block, other_block)
# blocks with same number of dots
the_block = make_block({(-2, 2), (-2, 3), (-2, 4), (-2, 5)})
other_block = make_block({(0, 0), (0, 1), (0, 2), (1,2)})
assert not are_equivalent(the_block, other_block)
